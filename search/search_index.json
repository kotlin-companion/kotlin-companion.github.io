{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Objetivos \u00b6 Kotlin Companion tem como objetivo ser um documento auxiliar de kotlin em l\u00edngua portugu\u00easa. N\u00e3o s\u00f3 apenas traduzindo melhor do que for encontrado na web sobre essa incr\u00edvel linguagem de programa\u00e7\u00e3o, de forma sucinta, como tamb\u00e9m mostrando as boas pr\u00e1ticas de programa\u00e7\u00e3o. Outro prop\u00f3sito desse projeto \u00e9 baseado na convic\u00e7\u00e3o que a forma mais efetiva de aprender \u00e9 explicando. Contribuindo \u00b6 Compartilhando esse projeto em suas midias sociais Colocando esse projeto nos seus favoritos com um Star no Github Autor \u00b6 Leonardo Pereira Alves","title":"Home"},{"location":"#objetivos","text":"Kotlin Companion tem como objetivo ser um documento auxiliar de kotlin em l\u00edngua portugu\u00easa. N\u00e3o s\u00f3 apenas traduzindo melhor do que for encontrado na web sobre essa incr\u00edvel linguagem de programa\u00e7\u00e3o, de forma sucinta, como tamb\u00e9m mostrando as boas pr\u00e1ticas de programa\u00e7\u00e3o. Outro prop\u00f3sito desse projeto \u00e9 baseado na convic\u00e7\u00e3o que a forma mais efetiva de aprender \u00e9 explicando.","title":"Objetivos"},{"location":"#contribuindo","text":"Compartilhando esse projeto em suas midias sociais Colocando esse projeto nos seus favoritos com um Star no Github","title":"Contribuindo"},{"location":"#autor","text":"Leonardo Pereira Alves","title":"Autor"},{"location":"estruturas-de-decisao/","text":"","title":"Estruturas de decis\u00e3o"},{"location":"estruturas-de-repeticao/","text":"","title":"Estruturas de repetic\u00e3o"},{"location":"funcoes/","text":"","title":"Func\u00f5es"},{"location":"orientacao-objetos/","text":"","title":"Orienta\u00e7\u00e3o a Objetos"},{"location":"porque-kotlin/","text":"Porqu\u00ea Kotlin? \u00b6 A linguagem \u00b6 Kotlin \u00e9 uma linguagem de programa\u00e7\u00e3o open souce, multiplataforma desenvolvida pela JetBrains famosa por suas IDEs, ela assim como o Java \u00e9 compilada para bytecodes que s\u00e3o interpretados pela JVM (Java Virtual Machine). Kotlin combina os paradigmas de orienta\u00e7\u00e3o a objetos e programa\u00e7\u00e3o funcional. E pode ser compilada para javascript , assim como existe tamb\u00e9m o Kotlin/Native da qual permite a cria\u00e7\u00e3o de bin\u00e1rios nativos para sistemas operacionais como: iOS, MacOS, Windows e Linux. E esses bin\u00e1rios s\u00e3o execultados sem o uso da JVM. Um breve hist\u00f3rico \u00b6 2010 JetBrains inicia o projeto Kotlin 2011 Durante a JVM Language Submit a JetBrains revela a implementa\u00e7\u00e3o do Kotlin 2012 Kotlin foi colocado sob a licen\u00e7a Apache de c\u00f3digo aberto. 2016 Foi lan\u00e7ada a vers\u00e3o 1.0 a primeira est\u00e1vel da linguagem. 2017 No Google I/O foi anunciada como linguagem oficial de desenvolvimento Android. Anuncio de Kotlin como liguagem oficial para Android Caracter\u00edsticas \u00b6 Concisa \u00b6 Pois em rela\u00e7\u00e3o ao Java temos uma redu\u00e7\u00e3o significativa na quantidade e legibilidade de c\u00f3digo. Kotlin tem muito menos boilerplate code do que o Java. Boilerplate code Boilerplate \u00e9 um termo muito utilizado para se referir a trechos de documentos (por exemplo jur\u00eddicos) que s\u00e3o sempre os mesmos, de documento pra documento, de modo que n\u00e3o acrescentam muita coisa mas mesmo assim n\u00e3o podem ser omitidos. Voc\u00ea j\u00e1 deve ter visto em licen\u00e7as de software, por exemplo, a parte que diz que \"N\u00c3O H\u00c1 NENHUMA GARANTIA PARA O PROGRAMA, NO LIMITE PERMITIDO PELA LEI APLIC\u00c1VEL. EXCETO QUANDO...\" etc. Todo mundo j\u00e1 conhece, ningu\u00e9m nem l\u00ea porque j\u00e1 sabe de cor o que est\u00e1 escrito, mas o documento n\u00e3o estaria completo sem ela. Exemplo, imagine uma classe chamada livro com apenas dois atributos, autor e t\u00edtulo, em Java ela ficaria assim: J\u00e1 em Kotlin a mesma a classe seria implementada da seguinte forma: Observa\u00e7\u00e3o Em um primeiro momento, pode parecer que os m\u00e9todos getters e setters n\u00e3o existem na classe livro, mas na verdade eles est\u00e3o impl\u00edcito na mesma. Segura de refer\u00eancia nulas \u00b6 Em Kotlin por default todo objeto e vari\u00e1vel n\u00e3o pode ter valor nulo. Kotlin protege voc\u00ea de operar incorretamente em tipos nullable. Podemos usar uma chamada segura (safe call) que impede o um erro de refer\u00eancia nula(NullPointerException). Apesar de a v\u00e1riavel sobreNome ser nula, n\u00e3o havera um erro ao chamar a propriedade lenght . Nota Um NullPointerException \u00e9 uma exce\u00e7\u00e3o lan\u00e7ada quando um programa tenta acessar uma vari\u00e1vel ou objeto de mem\u00f3ria que n\u00e3o foi instanciado (ou melhor, inicializado) at\u00e9 o momento de sua chamada. Ou seja, o objeto ainda est\u00e1 nulo e n\u00e3o tem um valor definido. Interoper\u00e1vel \u00b6 Kotlin \u00e9 100% interoper\u00e1vel com o Java. Isso significa que podemos usar qualquer classe ou API que foi implementada em Java sem o menor problema. Isso \u00e9 gra\u00e7as ao fato do Kotlin gerar os mesmos bytescodes da JVM Java. Podemos ent\u00e3o ter uma inst\u00e2ncia da classe Carro.java no c\u00f3digo Kotin. M\u00e1gia pura!","title":"Porqu\u00ea Kotlin?"},{"location":"porque-kotlin/#porque-kotlin","text":"","title":"Porqu\u00ea Kotlin?"},{"location":"porque-kotlin/#a-linguagem","text":"Kotlin \u00e9 uma linguagem de programa\u00e7\u00e3o open souce, multiplataforma desenvolvida pela JetBrains famosa por suas IDEs, ela assim como o Java \u00e9 compilada para bytecodes que s\u00e3o interpretados pela JVM (Java Virtual Machine). Kotlin combina os paradigmas de orienta\u00e7\u00e3o a objetos e programa\u00e7\u00e3o funcional. E pode ser compilada para javascript , assim como existe tamb\u00e9m o Kotlin/Native da qual permite a cria\u00e7\u00e3o de bin\u00e1rios nativos para sistemas operacionais como: iOS, MacOS, Windows e Linux. E esses bin\u00e1rios s\u00e3o execultados sem o uso da JVM.","title":"A linguagem"},{"location":"porque-kotlin/#um-breve-historico","text":"2010 JetBrains inicia o projeto Kotlin 2011 Durante a JVM Language Submit a JetBrains revela a implementa\u00e7\u00e3o do Kotlin 2012 Kotlin foi colocado sob a licen\u00e7a Apache de c\u00f3digo aberto. 2016 Foi lan\u00e7ada a vers\u00e3o 1.0 a primeira est\u00e1vel da linguagem. 2017 No Google I/O foi anunciada como linguagem oficial de desenvolvimento Android. Anuncio de Kotlin como liguagem oficial para Android","title":"Um breve hist\u00f3rico"},{"location":"porque-kotlin/#caracteristicas","text":"","title":"Caracter\u00edsticas"},{"location":"porque-kotlin/#concisa","text":"Pois em rela\u00e7\u00e3o ao Java temos uma redu\u00e7\u00e3o significativa na quantidade e legibilidade de c\u00f3digo. Kotlin tem muito menos boilerplate code do que o Java. Boilerplate code Boilerplate \u00e9 um termo muito utilizado para se referir a trechos de documentos (por exemplo jur\u00eddicos) que s\u00e3o sempre os mesmos, de documento pra documento, de modo que n\u00e3o acrescentam muita coisa mas mesmo assim n\u00e3o podem ser omitidos. Voc\u00ea j\u00e1 deve ter visto em licen\u00e7as de software, por exemplo, a parte que diz que \"N\u00c3O H\u00c1 NENHUMA GARANTIA PARA O PROGRAMA, NO LIMITE PERMITIDO PELA LEI APLIC\u00c1VEL. EXCETO QUANDO...\" etc. Todo mundo j\u00e1 conhece, ningu\u00e9m nem l\u00ea porque j\u00e1 sabe de cor o que est\u00e1 escrito, mas o documento n\u00e3o estaria completo sem ela. Exemplo, imagine uma classe chamada livro com apenas dois atributos, autor e t\u00edtulo, em Java ela ficaria assim: J\u00e1 em Kotlin a mesma a classe seria implementada da seguinte forma: Observa\u00e7\u00e3o Em um primeiro momento, pode parecer que os m\u00e9todos getters e setters n\u00e3o existem na classe livro, mas na verdade eles est\u00e3o impl\u00edcito na mesma.","title":"Concisa"},{"location":"porque-kotlin/#segura-de-referencia-nulas","text":"Em Kotlin por default todo objeto e vari\u00e1vel n\u00e3o pode ter valor nulo. Kotlin protege voc\u00ea de operar incorretamente em tipos nullable. Podemos usar uma chamada segura (safe call) que impede o um erro de refer\u00eancia nula(NullPointerException). Apesar de a v\u00e1riavel sobreNome ser nula, n\u00e3o havera um erro ao chamar a propriedade lenght . Nota Um NullPointerException \u00e9 uma exce\u00e7\u00e3o lan\u00e7ada quando um programa tenta acessar uma vari\u00e1vel ou objeto de mem\u00f3ria que n\u00e3o foi instanciado (ou melhor, inicializado) at\u00e9 o momento de sua chamada. Ou seja, o objeto ainda est\u00e1 nulo e n\u00e3o tem um valor definido.","title":"Segura de refer\u00eancia nulas"},{"location":"porque-kotlin/#interoperavel","text":"Kotlin \u00e9 100% interoper\u00e1vel com o Java. Isso significa que podemos usar qualquer classe ou API que foi implementada em Java sem o menor problema. Isso \u00e9 gra\u00e7as ao fato do Kotlin gerar os mesmos bytescodes da JVM Java. Podemos ent\u00e3o ter uma inst\u00e2ncia da classe Carro.java no c\u00f3digo Kotin. M\u00e1gia pura!","title":"Interoper\u00e1vel"},{"location":"tipos-basicos/","text":"Em Kotlin, tudo \u00e9 objeto no sentido de que qualquer vari\u00e1vel possui propriedades e m\u00e9todos. Nesta se\u00e7\u00e3o, descrevemos os tipos b\u00e1sicos usados \u200b\u200bno Kotlin: n\u00fameros, caracteres, booleanos, matrizes e strings. N\u00fameros \u00b6 Kotlin manipula os n\u00fameros de maneira muito semelhante a do Java, e possuem tamanhos limitados, esses limites dependem da quantidade de bits que cada tipo n\u00famerico oculpa em mem\u00f3ria. O Kotlin fornece os seguintes tipos que representam n\u00fameros: Tipo Bit Valor Minimo Valor M\u00e1ximo Long 64 -9223372036854775808 9223372036854775807 Int 32 -2147483648 2147483647 Short 16 -32768 32767 Byte 8 -128 127 Os n\u00fameros de ponto flutuante v\u00eam em dois tipos, dependendo de quantos d\u00edgitos voc\u00ea precisa. Se voc\u00ea precisar de maior precis\u00e3o ou trabalhar com quantias monet\u00e1rias (ou outras situa\u00e7\u00f5es em que voc\u00ea deve ter resultados exatos), use o tipo n\u00e3o primitivo BigDecimal. Tipo Bit Observa\u00e7\u00f5es Double 64 16-17 d\u00edgitos significativos Float 32 6-7 d\u00edgitos significativos Underline \u00b6 Podemos usar underline para tornar os valores num\u00e9ricos mais leg\u00edveis. Convers\u00f5es \u00b6 Tipos menores n\u00e3o s\u00e3o subtipos de maiores. Se eles fossem, ter\u00edamos o seguinte problema. Tipo menores n\u00e3o s\u00e3o implicitamente convertidos em tipos maiores. Isso significa que n\u00e3o podemos atribuir um valor do tipo Byte a uma vari\u00e1vel Int sem uma convers\u00e3o expl\u00edcita. Podemos usar convers\u00f5es expl\u00edcitas para ampliar os n\u00fameros Cada tipo de n\u00famerico suporta os seguintes os met\u00f3dos convers\u00e3o. toByte (): Byte toShort (): Short toInt (): Int toLong (): Long toFloat (): Float toDouble (): Double toChar (): Char Char \u00b6 Char n\u00e3o podem ser tratados diretamente como n\u00fameros. Por\u00e9m, podemos converter explicitamente um char em um n\u00famero inteiro. Booleans \u00b6 Tipos booleanos s\u00e3o definidos como Boolean, e podem ter apenas dois valores true (verdadeiro) ou false(falso) da qual podemos execultar as seguintes opera\u00e7\u00f5es l\u00f3gicas. Opera\u00e7\u00f5es l\u00f3gicas \u00b6 Opera\u00e7\u00e3o Operador E && OU II N\u00e3o ! Metodos da classe Boolean. \u00b6 A classe Boolean possui m\u00e9todos para essas opera\u00e7\u00f5es, o que tornam a sintax ainda mais legivel. Arrays \u00b6 Strings \u00b6 Strings s\u00e3o comparadas com o operador == que verificar a sua igualdade estrutural. J\u00e1 o operador === verifica igualdade referencial e !== \u00e9 a sua contra parte de nega\u00e7\u00e3o. Nota Somente se a === b s\u00f3 ser\u00e1 avaliado como true somente se a e b apontarem para o mesmo objeto em mem\u00f3ria. Nota Para valores que s\u00e3o representados como tipos primitivos no tempo de execu\u00e7\u00e3o (por exemplo, o tipo Int), a verifica\u00e7\u00e3o da igualdade === \u00e9 equivalente \u00e0 verifica\u00e7\u00e3o == de verifica\u00e7\u00e3o. Strings s\u00e3o um conjutos de caracteres que podem ser acessados \u200b\u200bpor index. Os elementos de uma string podem ser iterados em um loop. Template \u00e9 um peda\u00e7o de c\u00f3digo que \u00e9 avaliado e seu resultado \u00e9 concatenado em uma string. Come\u00e7a com um sinal de d\u00f3lar $ e consiste em um nome vari\u00e1vel. Para acessar valores de propriedade ou m\u00e9todos de objetos devemos usar chaves.","title":"Tipos B\u00e1sicos"},{"location":"tipos-basicos/#numeros","text":"Kotlin manipula os n\u00fameros de maneira muito semelhante a do Java, e possuem tamanhos limitados, esses limites dependem da quantidade de bits que cada tipo n\u00famerico oculpa em mem\u00f3ria. O Kotlin fornece os seguintes tipos que representam n\u00fameros: Tipo Bit Valor Minimo Valor M\u00e1ximo Long 64 -9223372036854775808 9223372036854775807 Int 32 -2147483648 2147483647 Short 16 -32768 32767 Byte 8 -128 127 Os n\u00fameros de ponto flutuante v\u00eam em dois tipos, dependendo de quantos d\u00edgitos voc\u00ea precisa. Se voc\u00ea precisar de maior precis\u00e3o ou trabalhar com quantias monet\u00e1rias (ou outras situa\u00e7\u00f5es em que voc\u00ea deve ter resultados exatos), use o tipo n\u00e3o primitivo BigDecimal. Tipo Bit Observa\u00e7\u00f5es Double 64 16-17 d\u00edgitos significativos Float 32 6-7 d\u00edgitos significativos","title":"N\u00fameros"},{"location":"tipos-basicos/#underline","text":"Podemos usar underline para tornar os valores num\u00e9ricos mais leg\u00edveis.","title":"Underline"},{"location":"tipos-basicos/#conversoes","text":"Tipos menores n\u00e3o s\u00e3o subtipos de maiores. Se eles fossem, ter\u00edamos o seguinte problema. Tipo menores n\u00e3o s\u00e3o implicitamente convertidos em tipos maiores. Isso significa que n\u00e3o podemos atribuir um valor do tipo Byte a uma vari\u00e1vel Int sem uma convers\u00e3o expl\u00edcita. Podemos usar convers\u00f5es expl\u00edcitas para ampliar os n\u00fameros Cada tipo de n\u00famerico suporta os seguintes os met\u00f3dos convers\u00e3o. toByte (): Byte toShort (): Short toInt (): Int toLong (): Long toFloat (): Float toDouble (): Double toChar (): Char","title":"Convers\u00f5es"},{"location":"tipos-basicos/#char","text":"Char n\u00e3o podem ser tratados diretamente como n\u00fameros. Por\u00e9m, podemos converter explicitamente um char em um n\u00famero inteiro.","title":"Char"},{"location":"tipos-basicos/#booleans","text":"Tipos booleanos s\u00e3o definidos como Boolean, e podem ter apenas dois valores true (verdadeiro) ou false(falso) da qual podemos execultar as seguintes opera\u00e7\u00f5es l\u00f3gicas.","title":"Booleans"},{"location":"tipos-basicos/#operacoes-logicas","text":"Opera\u00e7\u00e3o Operador E && OU II N\u00e3o !","title":"Opera\u00e7\u00f5es l\u00f3gicas"},{"location":"tipos-basicos/#metodos-da-classe-boolean","text":"A classe Boolean possui m\u00e9todos para essas opera\u00e7\u00f5es, o que tornam a sintax ainda mais legivel.","title":"Metodos da classe Boolean."},{"location":"tipos-basicos/#arrays","text":"","title":"Arrays"},{"location":"tipos-basicos/#strings","text":"Strings s\u00e3o comparadas com o operador == que verificar a sua igualdade estrutural. J\u00e1 o operador === verifica igualdade referencial e !== \u00e9 a sua contra parte de nega\u00e7\u00e3o. Nota Somente se a === b s\u00f3 ser\u00e1 avaliado como true somente se a e b apontarem para o mesmo objeto em mem\u00f3ria. Nota Para valores que s\u00e3o representados como tipos primitivos no tempo de execu\u00e7\u00e3o (por exemplo, o tipo Int), a verifica\u00e7\u00e3o da igualdade === \u00e9 equivalente \u00e0 verifica\u00e7\u00e3o == de verifica\u00e7\u00e3o. Strings s\u00e3o um conjutos de caracteres que podem ser acessados \u200b\u200bpor index. Os elementos de uma string podem ser iterados em um loop. Template \u00e9 um peda\u00e7o de c\u00f3digo que \u00e9 avaliado e seu resultado \u00e9 concatenado em uma string. Come\u00e7a com um sinal de d\u00f3lar $ e consiste em um nome vari\u00e1vel. Para acessar valores de propriedade ou m\u00e9todos de objetos devemos usar chaves.","title":"Strings"}]}